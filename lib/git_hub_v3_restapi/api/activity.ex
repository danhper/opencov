# NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
# https://openapi-generator.tech
# Do not edit the class manually.

defmodule GitHubV3RESTAPI.Api.Activity do
  @moduledoc """
  API calls for all endpoints tagged `Activity`.
  """

  alias GitHubV3RESTAPI.Connection
  import GitHubV3RESTAPI.RequestBuilder

  @doc """
  Check if a repository is starred by the authenticated user

  ## Parameters

  - connection (GitHubV3RESTAPI.Connection): Connection to server
  - owner (String.t):
  - repo (String.t):
  - opts (KeywordList): [optional] Optional parameters
  ## Returns

  {:ok, nil} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec activity_check_repo_is_starred_by_authenticated_user(
          Tesla.Env.client(),
          String.t(),
          String.t(),
          keyword()
        ) :: {:ok, nil} | {:ok, GitHubV3RESTAPI.Model.BasicError.t()} | {:error, Tesla.Env.t()}
  def activity_check_repo_is_starred_by_authenticated_user(connection, owner, repo, _opts \\ []) do
    %{}
    |> method(:get)
    |> url("/user/starred/#{owner}/#{repo}")
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      {204, false},
      {404, %GitHubV3RESTAPI.Model.BasicError{}},
      {401, %GitHubV3RESTAPI.Model.BasicError{}},
      {304, false},
      {403, %GitHubV3RESTAPI.Model.BasicError{}}
    ])
  end

  @doc """
  Delete a repository subscription
  This endpoint should only be used to stop watching a repository. To control whether or not you wish to receive notifications from a repository, [set the repository's subscription manually](https://docs.github.com/rest/reference/activity#set-a-repository-subscription).

  ## Parameters

  - connection (GitHubV3RESTAPI.Connection): Connection to server
  - owner (String.t):
  - repo (String.t):
  - opts (KeywordList): [optional] Optional parameters
  ## Returns

  {:ok, nil} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec activity_delete_repo_subscription(Tesla.Env.client(), String.t(), String.t(), keyword()) ::
          {:ok, nil} | {:error, Tesla.Env.t()}
  def activity_delete_repo_subscription(connection, owner, repo, _opts \\ []) do
    %{}
    |> method(:delete)
    |> url("/repos/#{owner}/#{repo}/subscription")
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      {204, false}
    ])
  end

  @doc """
  Delete a thread subscription
  Mutes all future notifications for a conversation until you comment on the thread or get an **@mention**. If you are watching the repository of the thread, you will still receive notifications. To ignore future notifications for a repository you are watching, use the [Set a thread subscription](https://docs.github.com/rest/reference/activity#set-a-thread-subscription) endpoint and set `ignore` to `true`.

  ## Parameters

  - connection (GitHubV3RESTAPI.Connection): Connection to server
  - thread_id (integer()): thread_id parameter
  - opts (KeywordList): [optional] Optional parameters
  ## Returns

  {:ok, nil} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec activity_delete_thread_subscription(Tesla.Env.client(), integer(), keyword()) ::
          {:ok, nil} | {:ok, GitHubV3RESTAPI.Model.BasicError.t()} | {:error, Tesla.Env.t()}
  def activity_delete_thread_subscription(connection, thread_id, _opts \\ []) do
    %{}
    |> method(:delete)
    |> url("/notifications/threads/#{thread_id}/subscription")
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      {204, false},
      {304, false},
      {403, %GitHubV3RESTAPI.Model.BasicError{}},
      {401, %GitHubV3RESTAPI.Model.BasicError{}}
    ])
  end

  @doc """
  Get feeds
  GitHub provides several timeline resources in [Atom](http://en.wikipedia.org/wiki/Atom_(standard)) format. The Feeds API lists all the feeds available to the authenticated user:  *   **Timeline**: The GitHub global public timeline *   **User**: The public timeline for any user, using [URI template](https://docs.github.com/rest/overview/resources-in-the-rest-api#hypermedia) *   **Current user public**: The public timeline for the authenticated user *   **Current user**: The private timeline for the authenticated user *   **Current user actor**: The private timeline for activity created by the authenticated user *   **Current user organizations**: The private timeline for the organizations the authenticated user is a member of. *   **Security advisories**: A collection of public announcements that provide information about security-related vulnerabilities in software on GitHub.  **Note**: Private feeds are only returned when [authenticating via Basic Auth](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication) since current feed URIs use the older, non revocable auth tokens.

  ## Parameters

  - connection (GitHubV3RESTAPI.Connection): Connection to server
  - opts (KeywordList): [optional] Optional parameters
  ## Returns

  {:ok, GitHubV3RESTAPI.Model.Feed.t} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec activity_get_feeds(Tesla.Env.client(), keyword()) ::
          {:ok, GitHubV3RESTAPI.Model.Feed.t()} | {:error, Tesla.Env.t()}
  def activity_get_feeds(connection, _opts \\ []) do
    %{}
    |> method(:get)
    |> url("/feeds")
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      {200, %GitHubV3RESTAPI.Model.Feed{}}
    ])
  end

  @doc """
  Get a repository subscription

  ## Parameters

  - connection (GitHubV3RESTAPI.Connection): Connection to server
  - owner (String.t):
  - repo (String.t):
  - opts (KeywordList): [optional] Optional parameters
  ## Returns

  {:ok, GitHubV3RESTAPI.Model.RepositorySubscription.t} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec activity_get_repo_subscription(Tesla.Env.client(), String.t(), String.t(), keyword()) ::
          {:ok, nil}
          | {:ok, GitHubV3RESTAPI.Model.BasicError.t()}
          | {:ok, GitHubV3RESTAPI.Model.RepositorySubscription.t()}
          | {:error, Tesla.Env.t()}
  def activity_get_repo_subscription(connection, owner, repo, _opts \\ []) do
    %{}
    |> method(:get)
    |> url("/repos/#{owner}/#{repo}/subscription")
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      {200, %GitHubV3RESTAPI.Model.RepositorySubscription{}},
      {404, false},
      {403, %GitHubV3RESTAPI.Model.BasicError{}}
    ])
  end

  @doc """
  Get a thread

  ## Parameters

  - connection (GitHubV3RESTAPI.Connection): Connection to server
  - thread_id (integer()): thread_id parameter
  - opts (KeywordList): [optional] Optional parameters
  ## Returns

  {:ok, GitHubV3RESTAPI.Model.Thread.t} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec activity_get_thread(Tesla.Env.client(), integer(), keyword()) ::
          {:ok, nil}
          | {:ok, GitHubV3RESTAPI.Model.Thread.t()}
          | {:ok, GitHubV3RESTAPI.Model.BasicError.t()}
          | {:error, Tesla.Env.t()}
  def activity_get_thread(connection, thread_id, _opts \\ []) do
    %{}
    |> method(:get)
    |> url("/notifications/threads/#{thread_id}")
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      {200, %GitHubV3RESTAPI.Model.Thread{}},
      {304, false},
      {403, %GitHubV3RESTAPI.Model.BasicError{}},
      {401, %GitHubV3RESTAPI.Model.BasicError{}}
    ])
  end

  @doc """
  Get a thread subscription for the authenticated user
  This checks to see if the current user is subscribed to a thread. You can also [get a repository subscription](https://docs.github.com/rest/reference/activity#get-a-repository-subscription).  Note that subscriptions are only generated if a user is participating in a conversation--for example, they've replied to the thread, were **@mentioned**, or manually subscribe to a thread.

  ## Parameters

  - connection (GitHubV3RESTAPI.Connection): Connection to server
  - thread_id (integer()): thread_id parameter
  - opts (KeywordList): [optional] Optional parameters
  ## Returns

  {:ok, GitHubV3RESTAPI.Model.ThreadSubscription.t} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec activity_get_thread_subscription_for_authenticated_user(
          Tesla.Env.client(),
          integer(),
          keyword()
        ) ::
          {:ok, nil}
          | {:ok, GitHubV3RESTAPI.Model.ThreadSubscription.t()}
          | {:ok, GitHubV3RESTAPI.Model.BasicError.t()}
          | {:error, Tesla.Env.t()}
  def activity_get_thread_subscription_for_authenticated_user(connection, thread_id, _opts \\ []) do
    %{}
    |> method(:get)
    |> url("/notifications/threads/#{thread_id}/subscription")
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      {200, %GitHubV3RESTAPI.Model.ThreadSubscription{}},
      {304, false},
      {403, %GitHubV3RESTAPI.Model.BasicError{}},
      {401, %GitHubV3RESTAPI.Model.BasicError{}}
    ])
  end

  @doc """
  List events for the authenticated user
  If you are authenticated as the given user, you will see your private events. Otherwise, you'll only see public events.

  ## Parameters

  - connection (GitHubV3RESTAPI.Connection): Connection to server
  - username (String.t):
  - opts (KeywordList): [optional] Optional parameters
    - :per_page (integer()): Results per page (max 100)
    - :page (integer()): Page number of the results to fetch.
  ## Returns

  {:ok, [%Event{}, ...]} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec activity_list_events_for_authenticated_user(Tesla.Env.client(), String.t(), keyword()) ::
          {:ok, list(GitHubV3RESTAPI.Model.Event.t())} | {:error, Tesla.Env.t()}
  def activity_list_events_for_authenticated_user(connection, username, opts \\ []) do
    optional_params = %{
      :per_page => :query,
      :page => :query
    }

    %{}
    |> method(:get)
    |> url("/users/#{username}/events")
    |> add_optional_params(optional_params, opts)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      {200, [%GitHubV3RESTAPI.Model.Event{}]}
    ])
  end

  @doc """
  List notifications for the authenticated user
  List all notifications for the current user, sorted by most recently updated.

  ## Parameters

  - connection (GitHubV3RESTAPI.Connection): Connection to server
  - opts (KeywordList): [optional] Optional parameters
    - :all (boolean()): If `true`, show notifications marked as read.
    - :participating (boolean()): If `true`, only shows notifications in which the user is directly participating or mentioned.
    - :since (DateTime.t): Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
    - :before (DateTime.t): Only show notifications updated before the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
    - :per_page (integer()): Results per page (max 100)
    - :page (integer()): Page number of the results to fetch.
  ## Returns

  {:ok, [%Thread{}, ...]} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec activity_list_notifications_for_authenticated_user(Tesla.Env.client(), keyword()) ::
          {:ok, nil}
          | {:ok, GitHubV3RESTAPI.Model.ValidationError.t()}
          | {:ok, list(GitHubV3RESTAPI.Model.Thread.t())}
          | {:ok, GitHubV3RESTAPI.Model.BasicError.t()}
          | {:error, Tesla.Env.t()}
  def activity_list_notifications_for_authenticated_user(connection, opts \\ []) do
    optional_params = %{
      :all => :query,
      :participating => :query,
      :since => :query,
      :before => :query,
      :per_page => :query,
      :page => :query
    }

    %{}
    |> method(:get)
    |> url("/notifications")
    |> add_optional_params(optional_params, opts)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      {200, [%GitHubV3RESTAPI.Model.Thread{}]},
      {304, false},
      {403, %GitHubV3RESTAPI.Model.BasicError{}},
      {401, %GitHubV3RESTAPI.Model.BasicError{}},
      {422, %GitHubV3RESTAPI.Model.ValidationError{}}
    ])
  end

  @doc """
  List organization events for the authenticated user
  This is the user's organization dashboard. You must be authenticated as the user to view this.

  ## Parameters

  - connection (GitHubV3RESTAPI.Connection): Connection to server
  - username (String.t):
  - org (String.t):
  - opts (KeywordList): [optional] Optional parameters
    - :per_page (integer()): Results per page (max 100)
    - :page (integer()): Page number of the results to fetch.
  ## Returns

  {:ok, [%Event{}, ...]} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec activity_list_org_events_for_authenticated_user(
          Tesla.Env.client(),
          String.t(),
          String.t(),
          keyword()
        ) :: {:ok, list(GitHubV3RESTAPI.Model.Event.t())} | {:error, Tesla.Env.t()}
  def activity_list_org_events_for_authenticated_user(connection, username, org, opts \\ []) do
    optional_params = %{
      :per_page => :query,
      :page => :query
    }

    %{}
    |> method(:get)
    |> url("/users/#{username}/events/orgs/#{org}")
    |> add_optional_params(optional_params, opts)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      {200, [%GitHubV3RESTAPI.Model.Event{}]}
    ])
  end

  @doc """
  List public events
  We delay the public events feed by five minutes, which means the most recent event returned by the public events API actually occurred at least five minutes ago.

  ## Parameters

  - connection (GitHubV3RESTAPI.Connection): Connection to server
  - opts (KeywordList): [optional] Optional parameters
    - :per_page (integer()): Results per page (max 100)
    - :page (integer()): Page number of the results to fetch.
  ## Returns

  {:ok, [%Event{}, ...]} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec activity_list_public_events(Tesla.Env.client(), keyword()) ::
          {:ok, nil}
          | {:ok, list(GitHubV3RESTAPI.Model.Event.t())}
          | {:ok, GitHubV3RESTAPI.Model.BasicError.t()}
          | {:ok, GitHubV3RESTAPI.Model.InlineResponse503.t()}
          | {:error, Tesla.Env.t()}
  def activity_list_public_events(connection, opts \\ []) do
    optional_params = %{
      :per_page => :query,
      :page => :query
    }

    %{}
    |> method(:get)
    |> url("/events")
    |> add_optional_params(optional_params, opts)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      {200, [%GitHubV3RESTAPI.Model.Event{}]},
      {304, false},
      {403, %GitHubV3RESTAPI.Model.BasicError{}},
      {503, %GitHubV3RESTAPI.Model.InlineResponse503{}}
    ])
  end

  @doc """
  List public events for a network of repositories

  ## Parameters

  - connection (GitHubV3RESTAPI.Connection): Connection to server
  - owner (String.t):
  - repo (String.t):
  - opts (KeywordList): [optional] Optional parameters
    - :per_page (integer()): Results per page (max 100)
    - :page (integer()): Page number of the results to fetch.
  ## Returns

  {:ok, [%Event{}, ...]} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec activity_list_public_events_for_repo_network(
          Tesla.Env.client(),
          String.t(),
          String.t(),
          keyword()
        ) ::
          {:ok, nil}
          | {:ok, list(GitHubV3RESTAPI.Model.Event.t())}
          | {:ok, GitHubV3RESTAPI.Model.BasicError.t()}
          | {:error, Tesla.Env.t()}
  def activity_list_public_events_for_repo_network(connection, owner, repo, opts \\ []) do
    optional_params = %{
      :per_page => :query,
      :page => :query
    }

    %{}
    |> method(:get)
    |> url("/networks/#{owner}/#{repo}/events")
    |> add_optional_params(optional_params, opts)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      {200, [%GitHubV3RESTAPI.Model.Event{}]},
      {404, %GitHubV3RESTAPI.Model.BasicError{}},
      {403, %GitHubV3RESTAPI.Model.BasicError{}},
      {304, false},
      {301, %GitHubV3RESTAPI.Model.BasicError{}}
    ])
  end

  @doc """
  List public events for a user

  ## Parameters

  - connection (GitHubV3RESTAPI.Connection): Connection to server
  - username (String.t):
  - opts (KeywordList): [optional] Optional parameters
    - :per_page (integer()): Results per page (max 100)
    - :page (integer()): Page number of the results to fetch.
  ## Returns

  {:ok, [%Event{}, ...]} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec activity_list_public_events_for_user(Tesla.Env.client(), String.t(), keyword()) ::
          {:ok, list(GitHubV3RESTAPI.Model.Event.t())} | {:error, Tesla.Env.t()}
  def activity_list_public_events_for_user(connection, username, opts \\ []) do
    optional_params = %{
      :per_page => :query,
      :page => :query
    }

    %{}
    |> method(:get)
    |> url("/users/#{username}/events/public")
    |> add_optional_params(optional_params, opts)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      {200, [%GitHubV3RESTAPI.Model.Event{}]}
    ])
  end

  @doc """
  List public organization events

  ## Parameters

  - connection (GitHubV3RESTAPI.Connection): Connection to server
  - org (String.t):
  - opts (KeywordList): [optional] Optional parameters
    - :per_page (integer()): Results per page (max 100)
    - :page (integer()): Page number of the results to fetch.
  ## Returns

  {:ok, [%Event{}, ...]} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec activity_list_public_org_events(Tesla.Env.client(), String.t(), keyword()) ::
          {:ok, list(GitHubV3RESTAPI.Model.Event.t())} | {:error, Tesla.Env.t()}
  def activity_list_public_org_events(connection, org, opts \\ []) do
    optional_params = %{
      :per_page => :query,
      :page => :query
    }

    %{}
    |> method(:get)
    |> url("/orgs/#{org}/events")
    |> add_optional_params(optional_params, opts)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      {200, [%GitHubV3RESTAPI.Model.Event{}]}
    ])
  end

  @doc """
  List events received by the authenticated user
  These are events that you've received by watching repos and following users. If you are authenticated as the given user, you will see private events. Otherwise, you'll only see public events.

  ## Parameters

  - connection (GitHubV3RESTAPI.Connection): Connection to server
  - username (String.t):
  - opts (KeywordList): [optional] Optional parameters
    - :per_page (integer()): Results per page (max 100)
    - :page (integer()): Page number of the results to fetch.
  ## Returns

  {:ok, [%Event{}, ...]} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec activity_list_received_events_for_user(Tesla.Env.client(), String.t(), keyword()) ::
          {:ok, list(GitHubV3RESTAPI.Model.Event.t())} | {:error, Tesla.Env.t()}
  def activity_list_received_events_for_user(connection, username, opts \\ []) do
    optional_params = %{
      :per_page => :query,
      :page => :query
    }

    %{}
    |> method(:get)
    |> url("/users/#{username}/received_events")
    |> add_optional_params(optional_params, opts)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      {200, [%GitHubV3RESTAPI.Model.Event{}]}
    ])
  end

  @doc """
  List public events received by a user

  ## Parameters

  - connection (GitHubV3RESTAPI.Connection): Connection to server
  - username (String.t):
  - opts (KeywordList): [optional] Optional parameters
    - :per_page (integer()): Results per page (max 100)
    - :page (integer()): Page number of the results to fetch.
  ## Returns

  {:ok, [%Event{}, ...]} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec activity_list_received_public_events_for_user(Tesla.Env.client(), String.t(), keyword()) ::
          {:ok, list(GitHubV3RESTAPI.Model.Event.t())} | {:error, Tesla.Env.t()}
  def activity_list_received_public_events_for_user(connection, username, opts \\ []) do
    optional_params = %{
      :per_page => :query,
      :page => :query
    }

    %{}
    |> method(:get)
    |> url("/users/#{username}/received_events/public")
    |> add_optional_params(optional_params, opts)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      {200, [%GitHubV3RESTAPI.Model.Event{}]}
    ])
  end

  @doc """
  List repository events

  ## Parameters

  - connection (GitHubV3RESTAPI.Connection): Connection to server
  - owner (String.t):
  - repo (String.t):
  - opts (KeywordList): [optional] Optional parameters
    - :per_page (integer()): Results per page (max 100)
    - :page (integer()): Page number of the results to fetch.
  ## Returns

  {:ok, [%Event{}, ...]} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec activity_list_repo_events(Tesla.Env.client(), String.t(), String.t(), keyword()) ::
          {:ok, list(GitHubV3RESTAPI.Model.Event.t())} | {:error, Tesla.Env.t()}
  def activity_list_repo_events(connection, owner, repo, opts \\ []) do
    optional_params = %{
      :per_page => :query,
      :page => :query
    }

    %{}
    |> method(:get)
    |> url("/repos/#{owner}/#{repo}/events")
    |> add_optional_params(optional_params, opts)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      {200, [%GitHubV3RESTAPI.Model.Event{}]}
    ])
  end

  @doc """
  List repository notifications for the authenticated user
  List all notifications for the current user.

  ## Parameters

  - connection (GitHubV3RESTAPI.Connection): Connection to server
  - owner (String.t):
  - repo (String.t):
  - opts (KeywordList): [optional] Optional parameters
    - :all (boolean()): If `true`, show notifications marked as read.
    - :participating (boolean()): If `true`, only shows notifications in which the user is directly participating or mentioned.
    - :since (DateTime.t): Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
    - :before (DateTime.t): Only show notifications updated before the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
    - :per_page (integer()): Results per page (max 100)
    - :page (integer()): Page number of the results to fetch.
  ## Returns

  {:ok, [%Thread{}, ...]} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec activity_list_repo_notifications_for_authenticated_user(
          Tesla.Env.client(),
          String.t(),
          String.t(),
          keyword()
        ) :: {:ok, list(GitHubV3RESTAPI.Model.Thread.t())} | {:error, Tesla.Env.t()}
  def activity_list_repo_notifications_for_authenticated_user(connection, owner, repo, opts \\ []) do
    optional_params = %{
      :all => :query,
      :participating => :query,
      :since => :query,
      :before => :query,
      :per_page => :query,
      :page => :query
    }

    %{}
    |> method(:get)
    |> url("/repos/#{owner}/#{repo}/notifications")
    |> add_optional_params(optional_params, opts)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      {200, [%GitHubV3RESTAPI.Model.Thread{}]}
    ])
  end

  @doc """
  List repositories starred by the authenticated user
  Lists repositories the authenticated user has starred.  You can also find out _when_ stars were created by passing the following custom [media type](https://docs.github.com/rest/overview/media-types/) via the `Accept` header:

  ## Parameters

  - connection (GitHubV3RESTAPI.Connection): Connection to server
  - opts (KeywordList): [optional] Optional parameters
    - :sort (String.t): One of `created` (when the repository was starred) or `updated` (when it was last pushed to).
    - :direction (String.t): One of `asc` (ascending) or `desc` (descending).
    - :per_page (integer()): Results per page (max 100)
    - :page (integer()): Page number of the results to fetch.
  ## Returns

  {:ok, [%Repository{}, ...]} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec activity_list_repos_starred_by_authenticated_user(Tesla.Env.client(), keyword()) ::
          {:ok, nil}
          | {:ok, list(GitHubV3RESTAPI.Model.Repository.t())}
          | {:ok, GitHubV3RESTAPI.Model.BasicError.t()}
          | {:error, Tesla.Env.t()}
  def activity_list_repos_starred_by_authenticated_user(connection, opts \\ []) do
    optional_params = %{
      :sort => :query,
      :direction => :query,
      :per_page => :query,
      :page => :query
    }

    %{}
    |> method(:get)
    |> url("/user/starred")
    |> add_optional_params(optional_params, opts)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      {200, [%GitHubV3RESTAPI.Model.Repository{}]},
      {304, false},
      {403, %GitHubV3RESTAPI.Model.BasicError{}},
      {401, %GitHubV3RESTAPI.Model.BasicError{}}
    ])
  end

  @doc """
  List repositories starred by a user
  Lists repositories a user has starred.  You can also find out _when_ stars were created by passing the following custom [media type](https://docs.github.com/rest/overview/media-types/) via the `Accept` header:

  ## Parameters

  - connection (GitHubV3RESTAPI.Connection): Connection to server
  - username (String.t):
  - opts (KeywordList): [optional] Optional parameters
    - :sort (String.t): One of `created` (when the repository was starred) or `updated` (when it was last pushed to).
    - :direction (String.t): One of `asc` (ascending) or `desc` (descending).
    - :per_page (integer()): Results per page (max 100)
    - :page (integer()): Page number of the results to fetch.
  ## Returns

  {:ok, AnyOfarrayarray} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec activity_list_repos_starred_by_user(Tesla.Env.client(), String.t(), keyword()) ::
          {:ok, GitHubV3RESTAPI.Model.AnyOfarrayarray.t()} | {:error, Tesla.Env.t()}
  def activity_list_repos_starred_by_user(connection, username, opts \\ []) do
    optional_params = %{
      :sort => :query,
      :direction => :query,
      :per_page => :query,
      :page => :query
    }

    %{}
    |> method(:get)
    |> url("/users/#{username}/starred")
    |> add_optional_params(optional_params, opts)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      {200, false}
    ])
  end

  @doc """
  List repositories watched by a user
  Lists repositories a user is watching.

  ## Parameters

  - connection (GitHubV3RESTAPI.Connection): Connection to server
  - username (String.t):
  - opts (KeywordList): [optional] Optional parameters
    - :per_page (integer()): Results per page (max 100)
    - :page (integer()): Page number of the results to fetch.
  ## Returns

  {:ok, [%MinimalRepository{}, ...]} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec activity_list_repos_watched_by_user(Tesla.Env.client(), String.t(), keyword()) ::
          {:ok, list(GitHubV3RESTAPI.Model.MinimalRepository.t())} | {:error, Tesla.Env.t()}
  def activity_list_repos_watched_by_user(connection, username, opts \\ []) do
    optional_params = %{
      :per_page => :query,
      :page => :query
    }

    %{}
    |> method(:get)
    |> url("/users/#{username}/subscriptions")
    |> add_optional_params(optional_params, opts)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      {200, [%GitHubV3RESTAPI.Model.MinimalRepository{}]}
    ])
  end

  @doc """
  List stargazers
  Lists the people that have starred the repository.  You can also find out _when_ stars were created by passing the following custom [media type](https://docs.github.com/rest/overview/media-types/) via the `Accept` header:

  ## Parameters

  - connection (GitHubV3RESTAPI.Connection): Connection to server
  - owner (String.t):
  - repo (String.t):
  - opts (KeywordList): [optional] Optional parameters
    - :per_page (integer()): Results per page (max 100)
    - :page (integer()): Page number of the results to fetch.
  ## Returns

  {:ok, AnyOfarrayarray} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec activity_list_stargazers_for_repo(Tesla.Env.client(), String.t(), String.t(), keyword()) ::
          {:ok, GitHubV3RESTAPI.Model.ValidationError.t()}
          | {:ok, GitHubV3RESTAPI.Model.AnyOfarrayarray.t()}
          | {:error, Tesla.Env.t()}
  def activity_list_stargazers_for_repo(connection, owner, repo, opts \\ []) do
    optional_params = %{
      :per_page => :query,
      :page => :query
    }

    %{}
    |> method(:get)
    |> url("/repos/#{owner}/#{repo}/stargazers")
    |> add_optional_params(optional_params, opts)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      {200, false},
      {422, %GitHubV3RESTAPI.Model.ValidationError{}}
    ])
  end

  @doc """
  List repositories watched by the authenticated user
  Lists repositories the authenticated user is watching.

  ## Parameters

  - connection (GitHubV3RESTAPI.Connection): Connection to server
  - opts (KeywordList): [optional] Optional parameters
    - :per_page (integer()): Results per page (max 100)
    - :page (integer()): Page number of the results to fetch.
  ## Returns

  {:ok, [%MinimalRepository{}, ...]} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec activity_list_watched_repos_for_authenticated_user(Tesla.Env.client(), keyword()) ::
          {:ok, nil}
          | {:ok, GitHubV3RESTAPI.Model.BasicError.t()}
          | {:ok, list(GitHubV3RESTAPI.Model.MinimalRepository.t())}
          | {:error, Tesla.Env.t()}
  def activity_list_watched_repos_for_authenticated_user(connection, opts \\ []) do
    optional_params = %{
      :per_page => :query,
      :page => :query
    }

    %{}
    |> method(:get)
    |> url("/user/subscriptions")
    |> add_optional_params(optional_params, opts)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      {200, [%GitHubV3RESTAPI.Model.MinimalRepository{}]},
      {304, false},
      {403, %GitHubV3RESTAPI.Model.BasicError{}},
      {401, %GitHubV3RESTAPI.Model.BasicError{}}
    ])
  end

  @doc """
  List watchers
  Lists the people watching the specified repository.

  ## Parameters

  - connection (GitHubV3RESTAPI.Connection): Connection to server
  - owner (String.t):
  - repo (String.t):
  - opts (KeywordList): [optional] Optional parameters
    - :per_page (integer()): Results per page (max 100)
    - :page (integer()): Page number of the results to fetch.
  ## Returns

  {:ok, [%SimpleUser{}, ...]} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec activity_list_watchers_for_repo(Tesla.Env.client(), String.t(), String.t(), keyword()) ::
          {:ok, list(GitHubV3RESTAPI.Model.SimpleUser.t())} | {:error, Tesla.Env.t()}
  def activity_list_watchers_for_repo(connection, owner, repo, opts \\ []) do
    optional_params = %{
      :per_page => :query,
      :page => :query
    }

    %{}
    |> method(:get)
    |> url("/repos/#{owner}/#{repo}/subscribers")
    |> add_optional_params(optional_params, opts)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      {200, [%GitHubV3RESTAPI.Model.SimpleUser{}]}
    ])
  end

  @doc """
  Mark notifications as read
  Marks all notifications as \"read\" removes it from the [default view on GitHub](https://github.com/notifications). If the number of notifications is too large to complete in one request, you will receive a `202 Accepted` status and GitHub will run an asynchronous process to mark notifications as \"read.\" To check whether any \"unread\" notifications remain, you can use the [List notifications for the authenticated user](https://docs.github.com/rest/reference/activity#list-notifications-for-the-authenticated-user) endpoint and pass the query parameter `all=false`.

  ## Parameters

  - connection (GitHubV3RESTAPI.Connection): Connection to server
  - opts (KeywordList): [optional] Optional parameters
    - :body (InlineObject21):
  ## Returns

  {:ok, GitHubV3RESTAPI.Model.InlineResponse202.t} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec activity_mark_notifications_as_read(Tesla.Env.client(), keyword()) ::
          {:ok, nil}
          | {:ok, GitHubV3RESTAPI.Model.InlineResponse202.t()}
          | {:ok, GitHubV3RESTAPI.Model.BasicError.t()}
          | {:error, Tesla.Env.t()}
  def activity_mark_notifications_as_read(connection, opts \\ []) do
    optional_params = %{
      :body => :body
    }

    %{}
    |> method(:put)
    |> url("/notifications")
    |> add_optional_params(optional_params, opts)
    |> ensure_body()
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      {202, %GitHubV3RESTAPI.Model.InlineResponse202{}},
      {205, false},
      {304, false},
      {403, %GitHubV3RESTAPI.Model.BasicError{}},
      {401, %GitHubV3RESTAPI.Model.BasicError{}}
    ])
  end

  @doc """
  Mark repository notifications as read
  Marks all notifications in a repository as \"read\" removes them from the [default view on GitHub](https://github.com/notifications). If the number of notifications is too large to complete in one request, you will receive a `202 Accepted` status and GitHub will run an asynchronous process to mark notifications as \"read.\" To check whether any \"unread\" notifications remain, you can use the [List repository notifications for the authenticated user](https://docs.github.com/rest/reference/activity#list-repository-notifications-for-the-authenticated-user) endpoint and pass the query parameter `all=false`.

  ## Parameters

  - connection (GitHubV3RESTAPI.Connection): Connection to server
  - owner (String.t):
  - repo (String.t):
  - opts (KeywordList): [optional] Optional parameters
    - :body (InlineObject114):
  ## Returns

  {:ok, GitHubV3RESTAPI.Model.InlineResponse2021.t} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec activity_mark_repo_notifications_as_read(
          Tesla.Env.client(),
          String.t(),
          String.t(),
          keyword()
        ) ::
          {:ok, nil}
          | {:ok, GitHubV3RESTAPI.Model.InlineResponse2021.t()}
          | {:error, Tesla.Env.t()}
  def activity_mark_repo_notifications_as_read(connection, owner, repo, opts \\ []) do
    optional_params = %{
      :body => :body
    }

    %{}
    |> method(:put)
    |> url("/repos/#{owner}/#{repo}/notifications")
    |> add_optional_params(optional_params, opts)
    |> ensure_body()
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      {202, %GitHubV3RESTAPI.Model.InlineResponse2021{}},
      {205, false}
    ])
  end

  @doc """
  Mark a thread as read

  ## Parameters

  - connection (GitHubV3RESTAPI.Connection): Connection to server
  - thread_id (integer()): thread_id parameter
  - opts (KeywordList): [optional] Optional parameters
  ## Returns

  {:ok, nil} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec activity_mark_thread_as_read(Tesla.Env.client(), integer(), keyword()) ::
          {:ok, nil} | {:ok, GitHubV3RESTAPI.Model.BasicError.t()} | {:error, Tesla.Env.t()}
  def activity_mark_thread_as_read(connection, thread_id, _opts \\ []) do
    %{}
    |> method(:patch)
    |> url("/notifications/threads/#{thread_id}")
    |> ensure_body()
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      {205, false},
      {304, false},
      {403, %GitHubV3RESTAPI.Model.BasicError{}}
    ])
  end

  @doc """
  Set a repository subscription
  If you would like to watch a repository, set `subscribed` to `true`. If you would like to ignore notifications made within a repository, set `ignored` to `true`. If you would like to stop watching a repository, [delete the repository's subscription](https://docs.github.com/rest/reference/activity#delete-a-repository-subscription) completely.

  ## Parameters

  - connection (GitHubV3RESTAPI.Connection): Connection to server
  - owner (String.t):
  - repo (String.t):
  - opts (KeywordList): [optional] Optional parameters
    - :body (InlineObject136):
  ## Returns

  {:ok, GitHubV3RESTAPI.Model.RepositorySubscription.t} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec activity_set_repo_subscription(Tesla.Env.client(), String.t(), String.t(), keyword()) ::
          {:ok, GitHubV3RESTAPI.Model.RepositorySubscription.t()} | {:error, Tesla.Env.t()}
  def activity_set_repo_subscription(connection, owner, repo, opts \\ []) do
    optional_params = %{
      :body => :body
    }

    %{}
    |> method(:put)
    |> url("/repos/#{owner}/#{repo}/subscription")
    |> add_optional_params(optional_params, opts)
    |> ensure_body()
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      {200, %GitHubV3RESTAPI.Model.RepositorySubscription{}}
    ])
  end

  @doc """
  Set a thread subscription
  If you are watching a repository, you receive notifications for all threads by default. Use this endpoint to ignore future notifications for threads until you comment on the thread or get an **@mention**.  You can also use this endpoint to subscribe to threads that you are currently not receiving notifications for or to subscribed to threads that you have previously ignored.  Unsubscribing from a conversation in a repository that you are not watching is functionally equivalent to the [Delete a thread subscription](https://docs.github.com/rest/reference/activity#delete-a-thread-subscription) endpoint.

  ## Parameters

  - connection (GitHubV3RESTAPI.Connection): Connection to server
  - thread_id (integer()): thread_id parameter
  - opts (KeywordList): [optional] Optional parameters
    - :body (InlineObject22):
  ## Returns

  {:ok, GitHubV3RESTAPI.Model.ThreadSubscription.t} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec activity_set_thread_subscription(Tesla.Env.client(), integer(), keyword()) ::
          {:ok, nil}
          | {:ok, GitHubV3RESTAPI.Model.ThreadSubscription.t()}
          | {:ok, GitHubV3RESTAPI.Model.BasicError.t()}
          | {:error, Tesla.Env.t()}
  def activity_set_thread_subscription(connection, thread_id, opts \\ []) do
    optional_params = %{
      :body => :body
    }

    %{}
    |> method(:put)
    |> url("/notifications/threads/#{thread_id}/subscription")
    |> add_optional_params(optional_params, opts)
    |> ensure_body()
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      {200, %GitHubV3RESTAPI.Model.ThreadSubscription{}},
      {304, false},
      {403, %GitHubV3RESTAPI.Model.BasicError{}},
      {401, %GitHubV3RESTAPI.Model.BasicError{}}
    ])
  end

  @doc """
  Star a repository for the authenticated user
  Note that you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see \"[HTTP verbs](https://docs.github.com/rest/overview/resources-in-the-rest-api#http-verbs).\"

  ## Parameters

  - connection (GitHubV3RESTAPI.Connection): Connection to server
  - owner (String.t):
  - repo (String.t):
  - opts (KeywordList): [optional] Optional parameters
  ## Returns

  {:ok, nil} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec activity_star_repo_for_authenticated_user(
          Tesla.Env.client(),
          String.t(),
          String.t(),
          keyword()
        ) :: {:ok, nil} | {:ok, GitHubV3RESTAPI.Model.BasicError.t()} | {:error, Tesla.Env.t()}
  def activity_star_repo_for_authenticated_user(connection, owner, repo, _opts \\ []) do
    %{}
    |> method(:put)
    |> url("/user/starred/#{owner}/#{repo}")
    |> ensure_body()
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      {204, false},
      {403, %GitHubV3RESTAPI.Model.BasicError{}},
      {404, %GitHubV3RESTAPI.Model.BasicError{}},
      {401, %GitHubV3RESTAPI.Model.BasicError{}},
      {304, false}
    ])
  end

  @doc """
  Unstar a repository for the authenticated user

  ## Parameters

  - connection (GitHubV3RESTAPI.Connection): Connection to server
  - owner (String.t):
  - repo (String.t):
  - opts (KeywordList): [optional] Optional parameters
  ## Returns

  {:ok, nil} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec activity_unstar_repo_for_authenticated_user(
          Tesla.Env.client(),
          String.t(),
          String.t(),
          keyword()
        ) :: {:ok, nil} | {:ok, GitHubV3RESTAPI.Model.BasicError.t()} | {:error, Tesla.Env.t()}
  def activity_unstar_repo_for_authenticated_user(connection, owner, repo, _opts \\ []) do
    %{}
    |> method(:delete)
    |> url("/user/starred/#{owner}/#{repo}")
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      {204, false},
      {404, %GitHubV3RESTAPI.Model.BasicError{}},
      {401, %GitHubV3RESTAPI.Model.BasicError{}},
      {304, false},
      {403, %GitHubV3RESTAPI.Model.BasicError{}}
    ])
  end
end
